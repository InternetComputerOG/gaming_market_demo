from decimal import Decimal
from typing import Dict, Any, List, Optional
from typing_extensions import TypedDict

from app.config import get_supabase_client
from app.db.queries import fetch_engine_state, update_user_balance, insert_order, update_order_status, fetch_user_orders, get_current_config
from app.engine.orders import Order as EngineOrder, apply_orders
from app.engine.params import EngineParams
from app.engine.state import EngineState
from app.utils import usdc_amount, price_value, validate_size, validate_price, validate_balance_buy, validate_balance_sell, get_current_ms, safe_divide
from app.services.realtime import publish_event

class Order(TypedDict):
    order_id: str
    user_id: str
    outcome_i: int
    yes_no: str
    type: str
    is_buy: bool
    size: Decimal
    limit_price: Optional[Decimal]
    max_slippage: Optional[Decimal]
    af_opt_in: bool
    ts_ms: int

def submit_order(user_id: str, order_data: Dict[str, Any]) -> str:
    client = get_supabase_client()
    config = get_current_config(client)
    params: EngineParams = config['params']
    gas_fee = Decimal(params['gas_fee'])

    size = usdc_amount(order_data['size'])
    validate_size(size)

    is_buy = order_data['is_buy']
    yes_no = order_data['yes_no']
    outcome_i = order_data['outcome_i']
    order_type = order_data['type']
    af_opt_in = order_data['af_opt_in']
    ts_ms = get_current_ms()

    if config['status'] in ['FROZEN', 'RESOLVED']:
        raise ValueError("Trading is currently frozen or resolved")

    if order_type == 'LIMIT':
        limit_price = price_value(order_data['limit_price'])
        validate_price(limit_price)
        max_slippage = None
    else:
        limit_price = None
        max_slippage = Decimal(order_data.get('max_slippage', '0.05'))

    # Conservative balance validation including gas_fee
    state: EngineState = fetch_engine_state(client)
    binary = state['binaries'][outcome_i]
    current_p = Decimal(binary['p_yes' if yes_no == 'YES' else 'p_no'])
    est_price = current_p + Decimal('0.1') if is_buy else current_p - Decimal('0.1')  # Conservative 10% slippage est

    user_balance = Decimal(fetch_user_balance(client, user_id))
    if is_buy:
        validate_balance_buy(user_balance, size, est_price, gas_fee)
    else:
        user_tokens = Decimal(fetch_user_tokens(client, user_id, outcome_i, yes_no))
        validate_balance_sell(user_tokens, size)

    # Deduct gas_fee regardless of later rejection
    update_user_balance(client, user_id, -gas_fee)

    order: Order = {
        'order_id': '',  # Generated by DB
        'user_id': user_id,
        'outcome_i': outcome_i,
        'yes_no': yes_no,
        'type': order_type,
        'is_buy': is_buy,
        'size': size,
        'limit_price': limit_price,
        'max_slippage': max_slippage,
        'af_opt_in': af_opt_in,
        'ts_ms': ts_ms
    }

    order_id = insert_order(client, order)
    publish_event('demo', 'ORDER_SUBMITTED', {'order_id': order_id, 'user_id': user_id})

    return order_id

def cancel_order(order_id: str, user_id: str) -> None:
    client = get_supabase_client()
    order = fetch_order(client, order_id)
    if order['user_id'] != user_id or order['status'] != 'OPEN':
        raise ValueError("Invalid order cancellation")

    # For LIMIT, refund unfilled (pro-rata from lob_pool via engine)
    state: EngineState = fetch_engine_state(client)
    params: EngineParams = get_current_params(client)
    remaining = cancel_from_pool(state, order['outcome_i'], order['yes_no'], order['is_buy'], order['limit_price'], user_id, order['af_opt_in'])
    update_user_balance(client, user_id, remaining)  # Refund USDC or tokens

    update_order_status(client, order_id, 'CANCELED')
    publish_event('demo', 'ORDER_CANCELED', {'order_id': order_id, 'user_id': user_id})

def get_user_orders(user_id: str, status: Optional[str] = None) -> List[Dict[str, Any]]:
    client = get_supabase_client()
    return fetch_user_orders(client, user_id, status)

def estimate_slippage(outcome_i: int, yes_no: str, size: Decimal, is_buy: bool, max_slippage: Optional[Decimal]) -> Dict[str, Any]:
    client = get_supabase_client()
    state: EngineState = fetch_engine_state(client)  # Clone for sim
    params: EngineParams = get_current_params(client)
    current_time = get_current_ms() - config['start_ts']

    sim_order: EngineOrder = {
        'order_id': 'sim',
        'user_id': 'sim',
        'outcome_i': outcome_i,
        'yes_no': yes_no,
        'type': 'MARKET',
        'is_buy': is_buy,
        'size': size,
        'limit_price': None,
        'max_slippage': max_slippage,
        'af_opt_in': True,
        'ts_ms': current_time
    }

    fills, new_state, _ = apply_orders(state, [sim_order], params, current_time)

    if not fills:
        return {'estimated_slippage': Decimal('0'), 'would_reject': False, 'est_cost': Decimal('0')}

    fill = fills[0]
    effective_p = fill['price']
    binary = state['binaries'][outcome_i]
    current_p = Decimal(binary['p_yes' if yes_no == 'YES' else 'p_no'])
    slippage = safe_divide(effective_p - current_p if is_buy else current_p - effective_p, current_p)
    would_reject = max_slippage is not None and slippage > Decimal(max_slippage)
    est_cost = fill['size'] * effective_p + fill['fee']

    return {'estimated_slippage': slippage, 'would_reject': would_reject, 'est_cost': est_cost}