# services_orders.py_context.md

## Overview
Service module for managing order lifecycle in the Gaming Market Demo, including submission with validations (size/price/balance/binary state per TDD), cancellation from LOB pools with refunds, user order fetching, and slippage estimation via simulation (accounting for LOB/AMM/auto-fills per Implan §3). Handles gas fee deductions on submission (even if rejected, per Implan §3), publishes events, and integrates engine for estimates. (Lines 1-20: Imports/setup; 21-150: submit_order; 151-220: cancel_order; 221-230: get_user_orders; 231-end: estimate_slippage.)

## Key Exports/Interfaces
- **Order** (TypedDict, Lines 30-40): Defines order structure with fields: order_id (str), user_id (str), outcome_i (int), yes_no (str), type (str), is_buy (bool), size (Decimal), limit_price (Optional[Decimal]), max_slippage (Optional[Decimal]), af_opt_in (bool), ts_ms (int). Used for DB insertion and engine compatibility.
- **submit_order(user_id: str, order_data: Dict[str, Any]) -> str** (Lines 42-150): Submits order after config/status checks, validations (size/price/balance/binary per TDD), deducts gas_fee, inserts to DB as 'OPEN', publishes 'ORDER_SUBMITTED'. Raises ValueError on invalid (e.g., frozen, insufficient balance with est fees). Returns order_id. Implements conservative balance checks: for LIMIT, exact limit_price + est_trading_fee + gas; for MARKET, AMM cost *1.1 + gas or fallback validate_balance_buy.
- **cancel_order(order_id: str, user_id: str) -> None** (Lines 152-220): Cancels OPEN LIMIT order owned by user, calls cancel_from_pool for refund, saves state, updates status to 'CANCELED', refunds unfilled, publishes 'ORDER_CANCELED'. Raises ValueError if not found/owned/cancellable or failure.
- **get_user_orders(user_id: str, status: Optional[str] = None) -> List[Dict[str, Any]]** (Lines 222-223): Fetches user's orders filtered by status via db.queries.
- **estimate_slippage(outcome_i: int, yes_no: str, size: Decimal, is_buy: bool, max_slippage: Optional[Decimal]) -> Dict[str, Any]** (Lines 225-end): Simulates MARKET order execution on copied state with apply_orders to estimate slippage (as % diff from current_p), would_reject (if > max_slippage), est_cost (total incl fees), breakdown (lob_fill, amm_fill, total_fee, effective_price, filled_amount). Fallback to simple AMM cost if sim fails. Returns dict with keys: estimated_slippage (Decimal), would_reject (bool), est_cost (Decimal), breakdown (Dict), optional error/fallback.

## Dependencies/Imports
- Imports: decimal.Decimal, typing.Dict/Any/List/Optional, typing_extensions.TypedDict (Lines 1-4).
- From app: config.get_supabase_client, db.queries (fetch_engine_state/update_user_balance/insert_order/update_order_status/fetch_user_orders/get_current_config/fetch_user_balance/fetch_user_position/save_engine_state), engine.orders (EngineOrder/apply_orders), engine.params (EngineParams), engine.state (EngineState/get_p_yes/get_p_no), engine.lob_matching (cancel_from_pool/match_market_order), engine.amm_math (buy_cost_yes/buy_cost_no/sell_received_yes/sell_received_no), utils (usdc_amount/price_value/validate_size/validate_price/validate_balance_buy/validate_balance_sell/get_current_ms/safe_divide/validate_limit_price_bounds/validate_binary_state), services.realtime (publish_event) (Lines 6-20).
- Interactions: Fetches config/state via db; validates with utils; deducts/updates balances/positions via db; inserts/updates orders via db; simulates via engine.apply_orders (deepcopy state); publishes via realtime. Called by streamlit_app.py for UI submits/estimates; integrates with batch_runner.py for OPEN orders processing.

## Usage Notes
- Implements TDD order types/validations (MARKET with max_slippage, LIMIT with bounds), balance checks with new fee structure (f_match/2 est for LIMIT), binary state validation pre-submit; gas_fee deducted always (per Implan §3). Use Decimal for precision (convert to float for DB JSONB). For MARKET, slippage accounts for LOB/AMM via sim (abstracting penalties/auto-fills per TDD UX); UI in streamlit_app.py uses for previews/disables (e.g., would_reject or insufficient). Tie to Implan §3: Handles af_opt_in, ts_ms for FIFO; status 'OPEN' for batch pickup. Deterministic sim via sorted/current_time; fallback if AMM math fails.

## Edge Cases/Invariants
- Edges: Frozen/resolved → raise; zero size/price → validate errors; insufficient balance (incl est slippage buffer/gas) → raise; sell without tokens → validate_sell error; LIMIT price outside [p_min, p_max] → bounds error; sim no liquidity → {'estimated_slippage':0, 'would_reject':True, 'error':'No liquidity'}; total_filled=0 → slippage=0; max_slippage=None → no reject.
- Invariants: Gas deducted before insertion (even reject); order status 'OPEN' initially, remaining=size (updated by batch); is_buy stored for engine; state saved post-cancel; slippage >=0 (safe_divide handles zero); effective_price = total_cost / total_filled if filled>0 else current_p; total L_i preserved via engine calls; assumes N_active from state.active flags.

## Inconsistencies/Possible Issues
- In submit_order balance check for LIMIT buy (Lines 88-95): Uses est_trading_fee = f_match * size * limit_price /2, but per TDD/Implan, LIMIT adds to pool (no immediate match/AMM), so fee may be zero if unmatched; conservative but could over-reject viable orders. For MARKET buy, uses AMM cost *1.1 + gas (Lines 96-108), but 10% buffer arbitrary—may under/over-estimate vs sim in estimate_slippage; fallback validate_balance_buy uses current_p without slippage.
- Decimal/float conversions (e.g., Lines 135-145): Stores size/limit_price/max_slippage as float in DB, but uses Decimal internally—potential precision loss; recommend consistent Decimal str.
- In estimate_slippage sim (Lines 280-350): Uses sim_order with 'MARKET'/af_opt_in=True, but ignores actual af_opt_in; breakdown assumes fill['source']='lob'/else 'amm', but engine may not set 'source'—check engine.orders.py. Fills list from apply_orders, but sums assuming yes_no consistent; if no fills, returns 0 slippage but would_reject=True—UI in streamlit_app.py may disable incorrectly if liquidity exists but sim fails.
- Cancel_order fetches orders via fetch_user_orders (Line 160), but then saves state/updates via client—redundant client=get_supabase_client(); potential race if batch matches during cancel.
- Integration with streamlit_app.py: UI calls estimate_slippage for MARKET previews (disables if would_reject), but for LIMIT, UI est trading_fee = f_match * size * limit_price /2 (per context Line 300-350)—matches submit but inconsistent with actual (f_match only on cross-match, f on AMM); suggest unify est. Also, UI assumes est_cost / size for effective_price, but orders.py provides breakdown.effective_price—ensure UI uses for risk warnings (>0.8 high).
- Potential bug: In submit_order, after deduct gas (Line 122), if later raise (e.g., invalid binary), gas not refunded—per Implan, deduct always, but TDD no mention; could frustrate users on validation errors. In estimate_slippage fallback (Lines 360-400), est_cost for sell is est_received (proceeds), but UI may expect cost (negative?)—clarify dict keys for consistency.